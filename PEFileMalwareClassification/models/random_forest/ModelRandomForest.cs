using Microsoft.ML;
using Microsoft.ML.Transforms.Onnx;
using PeNet.Header.Pe;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace PEFileMalwareClassification.models.random_forest
{
    public class ModelRandomForest: IModel
    {
        private MLContext mLContext;
        private OnnxScoringEstimator pipeline;

        public ModelRandomForest()
        {
            var modelPath = Application.StartupPath + @"\models\rf_pe_file56.onnx";
            var outputColumnNames = new[] { "output_label" };
            var inputColumnNames = new[] { "float_input" };
            mLContext = new MLContext();
            pipeline = mLContext.Transforms.ApplyOnnxModel(outputColumnNames, inputColumnNames, modelPath);
        }

        public float[] ExtractFeatures(string path)
        {
            var pe = new PeNet.PeFile(path);
            var dosHeader = pe.ImageDosHeader;
            var ntHeader = pe.ImageNtHeaders;

            List<float> rawSizes = new List<float>();
            List<float> virtualSizes = new List<float>();
            List<float> importedFunctions = new List<float>();
            float importsNbOrdinal = 0;
            foreach (ImageSectionHeader section in pe.ImageSectionHeaders)
            {
                rawSizes.Add(section.SizeOfRawData);
                virtualSizes.Add(section.VirtualSize);
            }
            foreach (var function in pe.ImageImportDescriptors)
            {
                importedFunctions.Add(function.FirstThunk);
            }
            foreach (var function in pe.ImportedFunctions)
            {
                if (function.Name == null) { importsNbOrdinal++; }
            }
            List<float> output = new List<float>();
            output.Add(dosHeader.E_magic);
            output.Add(dosHeader.E_cblp);
            output.Add(dosHeader.E_cp);
            output.Add(dosHeader.E_crlc);
            output.Add(dosHeader.E_cparhdr);
            output.Add(dosHeader.E_minalloc);
            output.Add(dosHeader.E_maxalloc);
            output.Add(dosHeader.E_ss);
            output.Add(dosHeader.E_sp);
            output.Add(dosHeader.E_csum);
            output.Add(dosHeader.E_ip);
            output.Add(dosHeader.E_cs);
            output.Add(dosHeader.E_lfarlc);
            output.Add(dosHeader.E_ovno);
            output.Add(dosHeader.E_oemid);
            output.Add(dosHeader.E_oeminfo);
            output.Add(dosHeader.E_lfanew);
            output.Add((float)ntHeader.FileHeader.Machine);
            output.Add(ntHeader.FileHeader.SizeOfOptionalHeader);
            output.Add((float)ntHeader.FileHeader.Characteristics);
            output.Add(ntHeader.Signature);
            output.Add((float)ntHeader.OptionalHeader.Magic);
            output.Add(ntHeader.OptionalHeader.MajorLinkerVersion);
            output.Add(ntHeader.OptionalHeader.MinorLinkerVersion);
            output.Add(ntHeader.OptionalHeader.SizeOfCode);
            output.Add(ntHeader.OptionalHeader.SizeOfInitializedData);
            output.Add(ntHeader.OptionalHeader.SizeOfUninitializedData);
            output.Add(ntHeader.OptionalHeader.AddressOfEntryPoint);
            output.Add(ntHeader.OptionalHeader.BaseOfCode);
            output.Add(ntHeader.OptionalHeader.BaseOfData);
            output.Add(ntHeader.OptionalHeader.ImageBase);
            output.Add(ntHeader.OptionalHeader.SectionAlignment);
            output.Add(ntHeader.OptionalHeader.FileAlignment);
            output.Add(ntHeader.OptionalHeader.MajorOperatingSystemVersion);
            output.Add(ntHeader.OptionalHeader.MinorOperatingSystemVersion);
            output.Add(ntHeader.OptionalHeader.MajorImageVersion);
            output.Add(ntHeader.OptionalHeader.MinorImageVersion);
            output.Add(ntHeader.OptionalHeader.MajorSubsystemVersion);
            output.Add(ntHeader.OptionalHeader.MinorSubsystemVersion);
            output.Add(pe.ImageLoadConfigDirectory != null ? pe.ImageLoadConfigDirectory.Reserved1 : 0);
            output.Add(ntHeader.OptionalHeader.SizeOfImage);
            output.Add(ntHeader.OptionalHeader.SizeOfHeaders);
            output.Add(ntHeader.OptionalHeader.CheckSum);
            output.Add((float)ntHeader.OptionalHeader.Subsystem);
            output.Add((float)ntHeader.OptionalHeader.DllCharacteristics);
            output.Add(ntHeader.OptionalHeader.SizeOfStackReserve);
            output.Add(ntHeader.OptionalHeader.SizeOfStackCommit);
            output.Add(ntHeader.OptionalHeader.SizeOfHeapReserve);
            output.Add(ntHeader.OptionalHeader.SizeOfHeapCommit);
            output.Add(ntHeader.OptionalHeader.LoaderFlags);
            output.Add(ntHeader.OptionalHeader.NumberOfRvaAndSizes);
            output.Add(pe.ImageSectionHeaders.Length);
            output.Add(rawSizes.Average()); // MeanRawSize
            output.Add(virtualSizes.Average()); // MeanVirtualSize
            output.Add(importedFunctions.Count); // ImportsNbDLL;
            output.Add(importsNbOrdinal);
            return output.ToArray();
        }

        public float[] Predict(float[] input)
        {
            var inputVector = new InputVector { Data = input  };
            var dataView = mLContext.Data.LoadFromEnumerable(new List<InputVector> { inputVector });
            var transformedValues = pipeline.Fit(dataView).Transform(dataView);
            var output = mLContext.Data.CreateEnumerable<OutputVector>(transformedValues, reuseRowObject: false);
            return new float[] { output.First().Data[0] };
        }

        public Int64[] predict2(float[] input)
        {
            var inputVector = new InputVector { Data = input };
            var dataView = mLContext.Data.LoadFromEnumerable(new List<InputVector> { inputVector });
            var transformedValues = pipeline.Fit(dataView).Transform(dataView);
            var output = mLContext.Data.CreateEnumerable<OutputVector>(transformedValues, reuseRowObject: false);
            return output.First().Data;
        }
    }
}
